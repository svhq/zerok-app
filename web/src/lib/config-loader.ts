/**
 * Configuration Loader for Web UI
 *
 * Loads pool configuration from /config/<network>.json served by Next.js.
 * The config file is generated by scripts/generate-pool-config.js and
 * copied to web/public/config/ during build/dev.
 *
 * CRITICAL: This is the ONLY way to load pool configuration in the web app.
 * NO FALLBACKS - if config is missing, we fail fast.
 *
 * Web expects: /config/<network>.json (served from public/config/<network>.json)
 */

import { PoolConfig } from '@/types/note';
import type { Connection } from '@solana/web3.js';

// =============================================================================
// TYPES
// =============================================================================

/**
 * Generated pool configuration structure.
 * Matches output of scripts/generate-pool-config.js
 */
export interface GeneratedPoolConfig {
  poolId: string;
  programId: string;
  statePda: string;
  vaultPda: string;
  vkPda: string;
  metadataPda: string;
  rootRingPda: string;
  shardPdas: string[];
  denominationLamports: string;
  denominationSol: number;
  denominationDisplay: string;
  numShards: number;
  shardCapacity: number;
  ringCapacity: number;
}

/**
 * Full network configuration structure.
 */
export interface NetworkConfig {
  version: number;
  generatedAt: string;
  generator: string;
  network: string;
  rpcUrl: string;
  programId: string;
  protocolWallet: string | null;
  pools: GeneratedPoolConfig[];
  poolIds: string[];
  denominationsSol: number[];
  protocolConstants: {
    numShards: number;
    shardCapacity: number;
    ringCapacity: number;
    stateRootHistorySize: number;
    protocolFeeBps: number;
  };
  configHash: string;
}

// =============================================================================
// STATE
// =============================================================================

/** Cached configuration per network */
const configCache = new Map<string, NetworkConfig>();

/** Loading promises to prevent duplicate fetches */
const loadingPromises = new Map<string, Promise<NetworkConfig>>();

// =============================================================================
// HASH UTILITY
// =============================================================================

/**
 * Calculate SHA256 hash of config for integrity checking.
 * Uses SubtleCrypto in browser, falls back to simple hash if unavailable.
 *
 * CRITICAL: Must use JSON.stringify(config, null, 2) to match generator logic!
 * The generator in scripts/generate-pool-config.js uses the same stringify format.
 */
async function hashConfig(config: Omit<NetworkConfig, 'configHash'> | NetworkConfig): Promise<string> {
  // CRITICAL: Use pretty-printed JSON to match generator
  const content = JSON.stringify(config, null, 2);

  // Use SubtleCrypto (available in browsers and Node.js 18+)
  const encoder = new TextEncoder();
  const data = encoder.encode(content);
  const hashBuffer = await globalThis.crypto.subtle.digest('SHA-256', data as unknown as ArrayBuffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').substring(0, 16);
}

/**
 * Validate config hash integrity.
 * FAIL-CLOSED: Throws error if hash doesn't match.
 *
 * The generator computes hash BEFORE adding configHash to the config,
 * so we must clone the config, remove configHash, then hash.
 */
async function validateConfigHash(config: NetworkConfig): Promise<void> {
  if (!config.configHash) {
    console.warn('[Config] No configHash in config - skipping validation');
    return;
  }

  // Clone config and remove configHash (generator hashes BEFORE adding configHash)
  const configCopy = { ...config };
  delete (configCopy as Partial<NetworkConfig>).configHash;

  // Compute expected hash
  const expectedHash = await hashConfig(configCopy);

  // FAIL-CLOSED: Throw error if mismatch
  if (config.configHash !== expectedHash) {
    console.error(`[Config] HASH MISMATCH: stored=${config.configHash}, computed=${expectedHash}`);
    throw new Error(
      `Config integrity check failed - possible corruption or tampering. ` +
      `Stored hash: ${config.configHash}, Computed hash: ${expectedHash}. ` +
      `Regenerate config: node scripts/generate-pool-config.js <network>`
    );
  }

  console.log(`[Config] Hash validation passed: ${config.configHash}`);
}

// =============================================================================
// LOADER
// =============================================================================

/**
 * Load configuration for a network.
 *
 * Fetches from /config/<network>.json and caches the result.
 * NO FALLBACKS - fails fast if config is missing or invalid.
 *
 * @param network - Network name (localnet, devnet, mainnet-beta)
 * @returns NetworkConfig
 * @throws Error if config cannot be loaded
 */
export async function loadNetworkConfig(network: string): Promise<NetworkConfig> {
  // Check cache first
  const cached = configCache.get(network);
  if (cached) {
    return cached;
  }

  // Check if already loading (prevent duplicate fetches)
  const existing = loadingPromises.get(network);
  if (existing) {
    return existing;
  }

  // Start loading
  const loadPromise = (async () => {
    const configUrl = `/config/${network}.json`;

    console.log(`[Config] Loading from ${configUrl}...`);

    try {
      const response = await fetch(configUrl);

      if (!response.ok) {
        throw new Error(
          `Config not found: ${configUrl} (status: ${response.status}). ` +
          `Run: node scripts/generate-pool-config.js ${network} && ` +
          `cp generated/config/${network}.json web/public/config/`
        );
      }

      const config: NetworkConfig = await response.json();

      // Validate essential fields
      if (!config.programId) {
        throw new Error('Invalid config: missing programId');
      }
      if (!config.pools || config.pools.length === 0) {
        throw new Error('Invalid config: no pools defined');
      }

      // FAIL-CLOSED: Validate config hash integrity
      await validateConfigHash(config);

      console.log(`[Config] Loaded: network=${config.network}, program_id=${config.programId}, pools=${config.pools.length}`);

      // Cache the result
      configCache.set(network, config);

      return config;
    } finally {
      // Clean up loading promise
      loadingPromises.delete(network);
    }
  })();

  loadingPromises.set(network, loadPromise);
  return loadPromise;
}

/**
 * Get a specific pool configuration.
 *
 * @param network - Network name
 * @param poolId - Pool ID
 * @returns GeneratedPoolConfig
 * @throws Error if pool not found
 */
export async function loadPoolConfig(network: string, poolId: string): Promise<GeneratedPoolConfig> {
  const networkConfig = await loadNetworkConfig(network);

  const pool = networkConfig.pools.find(p => p.poolId === poolId);
  if (!pool) {
    const available = networkConfig.poolIds.join(', ');
    throw new Error(`Pool not found: ${poolId}. Available pools: ${available}`);
  }

  return pool;
}

/**
 * Convert GeneratedPoolConfig to legacy PoolConfig format for backward compatibility.
 *
 * @param pool - Generated pool config
 * @param networkConfig - Parent network config
 * @returns PoolConfig in legacy format
 */
export function toLegacyPoolConfig(
  pool: GeneratedPoolConfig,
  networkConfig: NetworkConfig
): PoolConfig {
  return {
    poolId: pool.poolId,
    programId: pool.programId,
    statePda: pool.statePda,
    vaultPda: pool.vaultPda,
    vkPda: pool.vkPda,
    metadataPda: pool.metadataPda,
    rootRingPda: pool.rootRingPda,
    shardPdas: pool.shardPdas,
    denominationLamports: parseInt(pool.denominationLamports, 10),
    denominationDisplay: pool.denominationDisplay,
    rpcUrl: networkConfig.rpcUrl,
    protocolWallet: networkConfig.protocolWallet || '',
    ringCapacity: pool.ringCapacity,
    shardCapacity: pool.shardCapacity,
    numShards: pool.numShards,
    allocatedShards: pool.numShards, // Assume all shards allocated
  };
}

/**
 * Load all pools for a network in legacy format.
 *
 * @param network - Network name
 * @returns Record of poolId -> PoolConfig
 */
export async function loadAllPoolsLegacy(network: string): Promise<Record<string, PoolConfig>> {
  const networkConfig = await loadNetworkConfig(network);

  const pools: Record<string, PoolConfig> = {};
  for (const pool of networkConfig.pools) {
    pools[pool.poolId] = toLegacyPoolConfig(pool, networkConfig);
  }

  return pools;
}

// =============================================================================
// SYNC ACCESS (for after initial load)
// =============================================================================

/**
 * Get cached network config synchronously.
 * Returns null if not yet loaded.
 *
 * @param network - Network name
 * @returns NetworkConfig or null
 */
export function getCachedConfig(network: string): NetworkConfig | null {
  return configCache.get(network) || null;
}

/**
 * Get cached pool config synchronously.
 * Returns null if not yet loaded.
 *
 * @param network - Network name
 * @param poolId - Pool ID
 * @returns GeneratedPoolConfig or null
 */
export function getCachedPool(network: string, poolId: string): GeneratedPoolConfig | null {
  const config = configCache.get(network);
  if (!config) return null;

  return config.pools.find(p => p.poolId === poolId) || null;
}

/**
 * Check if config is loaded for a network.
 *
 * @param network - Network name
 * @returns boolean
 */
export function isConfigLoaded(network: string): boolean {
  return configCache.has(network);
}

/**
 * Clear config cache.
 * Useful for hot-reloading during development.
 */
export function clearConfigCache(): void {
  configCache.clear();
  console.log('[Config] Cache cleared');
}

// =============================================================================
// INITIALIZATION HELPER
// =============================================================================

/**
 * Initialize configuration at app startup.
 *
 * Call this in your app's initialization (e.g., _app.tsx or layout.tsx).
 *
 * @param network - Network to load (defaults to NEXT_PUBLIC_NETWORK or 'devnet')
 * @returns NetworkConfig
 */
export async function initializeConfig(
  network?: string
): Promise<NetworkConfig> {
  // Determine network from environment or default
  const targetNetwork = network
    || (typeof process !== 'undefined' && process.env?.NEXT_PUBLIC_NETWORK)
    || 'devnet';

  console.log(`[Config] Initializing for network: ${targetNetwork}`);

  try {
    const config = await loadNetworkConfig(targetNetwork);
    console.log(`[Config] Ready: ${config.pools.length} pools available`);
    return config;
  } catch (err) {
    console.error('[Config] CRITICAL: Failed to load configuration');
    console.error('[Config] This is likely a build/deployment issue.');
    console.error('[Config] Run: pnpm run predev (or pnpm run prebuild)');
    throw err;
  }
}
