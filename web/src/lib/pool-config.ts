/**
 * Pool Configuration - Dynamic Loading from Generated Config
 *
 * ZERO-DRIFT ARCHITECTURE:
 * This file NO LONGER contains hardcoded pool configurations.
 * All pool data is loaded dynamically from /config/<network>.json.
 *
 * The config file is:
 * - Generated by: scripts/generate-pool-config.js
 * - Served from: web/public/config/<network>.json
 * - Loaded by: config-loader.ts
 *
 * MIGRATION NOTE:
 * If you see TypeScript errors about POOLS being undefined, ensure:
 * 1. initializePoolConfig() is called at app startup (in _app.tsx or layout.tsx)
 * 2. pnpm run predev (or prebuild) was run to generate config files
 */

import { PublicKey } from '@solana/web3.js';
import { executeWithRotation } from './resilient-connection';
import { PoolConfig } from '@/types/note';
import {
  loadNetworkConfig,
  loadAllPoolsLegacy,
  getCachedConfig,
  NetworkConfig,
  GeneratedPoolConfig,
  toLegacyPoolConfig,
} from './config-loader';

// =============================================================================
// STATE
// =============================================================================

/** Initialized pools (populated by initializePoolConfig) */
let _pools: Record<string, PoolConfig> | null = null;

/** Network config cache */
let _networkConfig: NetworkConfig | null = null;

/** Current network */
let _currentNetwork: string = 'devnet';

// =============================================================================
// INITIALIZATION
// =============================================================================

/**
 * Initialize pool configuration from generated config.
 *
 * MUST be called at app startup before using any pool functions.
 * Typically called in _app.tsx or layout.tsx.
 *
 * @param network - Network name (localnet, devnet, mainnet-beta)
 * @returns Promise that resolves when config is loaded
 * @throws Error if config cannot be loaded
 *
 * @example
 * // In _app.tsx or layout.tsx
 * useEffect(() => {
 *   initializePoolConfig(process.env.NEXT_PUBLIC_NETWORK || 'devnet')
 *     .catch(console.error);
 * }, []);
 */
export async function initializePoolConfig(network?: string): Promise<void> {
  const targetNetwork = network
    || (typeof process !== 'undefined' && process.env?.NEXT_PUBLIC_NETWORK)
    || 'devnet';

  console.log(`[PoolConfig] Initializing from generated config: ${targetNetwork}`);

  try {
    // Load from config-loader (fetches /config/<network>.json)
    _networkConfig = await loadNetworkConfig(targetNetwork);
    _pools = await loadAllPoolsLegacy(targetNetwork);
    _currentNetwork = targetNetwork;

    console.log(`[PoolConfig] Loaded ${Object.keys(_pools).length} pools for ${targetNetwork}`);
  } catch (err) {
    console.error('[PoolConfig] CRITICAL: Failed to load config');
    console.error('[PoolConfig] Run: pnpm run predev (or prebuild)');
    throw err;
  }
}

/**
 * Check if pool config has been initialized.
 */
export function isPoolConfigInitialized(): boolean {
  return _pools !== null && _networkConfig !== null;
}

/**
 * Get current network.
 */
export function getCurrentNetwork(): string {
  return _currentNetwork;
}

// =============================================================================
// POOL ACCESS
// =============================================================================

/**
 * Get all pools (throws if not initialized).
 *
 * @deprecated Use getPoolConfig(poolId) or getDeployedPools() instead
 */
export function getPools(): Record<string, PoolConfig> {
  if (!_pools) {
    throw new Error(
      'Pool config not initialized. Call initializePoolConfig() at app startup. ' +
      'See web/src/lib/pool-config.ts for details.'
    );
  }
  return _pools;
}

/**
 * All available pools keyed by poolId.
 *
 * MIGRATION: This is now a getter that returns initialized pools.
 * If you access POOLS before initializePoolConfig(), it will be empty.
 *
 * For new code, prefer using getPoolConfig(poolId) which provides better error messages.
 */
export const POOLS: Record<string, PoolConfig> = new Proxy({} as Record<string, PoolConfig>, {
  get(target, prop: string) {
    if (_pools && prop in _pools) {
      return _pools[prop];
    }
    // Check if it's a Symbol or built-in property
    if (typeof prop === 'symbol' || prop === 'then' || prop === 'toJSON') {
      return undefined;
    }
    // Warn about uninitialized access
    if (!_pools) {
      console.warn(
        `[PoolConfig] Accessing POOLS['${prop}'] before initialization. ` +
        'Call initializePoolConfig() first.'
      );
    }
    return undefined;
  },
  ownKeys() {
    return _pools ? Object.keys(_pools) : [];
  },
  getOwnPropertyDescriptor(target, prop) {
    if (_pools && prop in _pools) {
      return { enumerable: true, configurable: true, value: _pools[prop as string] };
    }
    return undefined;
  },
  has(target, prop) {
    return _pools ? prop in _pools : false;
  },
});

// =============================================================================
// POOL OPTIONS (for UI display)
// =============================================================================

/**
 * Get pool options for UI display.
 * Returns array sorted by denomination.
 */
export function getPoolOptions(): Array<{ id: string; label: string; deployed: boolean }> {
  if (!_networkConfig || !_pools) {
    return [];
  }

  return _networkConfig.pools
    .map(pool => ({
      id: pool.poolId,
      label: pool.denominationDisplay,
      deployed: true, // All pools in generated config are deployed
    }))
    .sort((a, b) => {
      // Sort by denomination (extract number from label like "0.12 SOL")
      const aNum = parseFloat(a.label);
      const bNum = parseFloat(b.label);
      return aNum - bNum;
    });
}

/**
 * Pool options for UI display.
 *
 * MIGRATION: Now dynamically generated from loaded config.
 */
export const POOL_OPTIONS: Array<{ id: string; label: string; deployed: boolean }> = new Proxy(
  [] as Array<{ id: string; label: string; deployed: boolean }>,
  {
    get(target, prop) {
      const options = getPoolOptions();
      if (prop === 'length') return options.length;
      if (prop === 'filter') return options.filter.bind(options);
      if (prop === 'map') return options.map.bind(options);
      if (prop === 'find') return options.find.bind(options);
      if (prop === 'forEach') return options.forEach.bind(options);
      if (typeof prop === 'string' && !isNaN(Number(prop))) {
        return options[Number(prop)];
      }
      if (prop === Symbol.iterator) {
        return function* () {
          for (const item of options) yield item;
        };
      }
      return (target as any)[prop];
    },
  }
);

// =============================================================================
// DEFAULT POOL
// =============================================================================

/**
 * Get default pool ID for current network.
 */
export function getDefaultPoolId(): string {
  if (!_networkConfig || _networkConfig.poolIds.length === 0) {
    return 'devnet-0p1sol-v2c-20shard'; // Fallback for uninitialized state
  }
  // Return first pool (smallest denomination)
  return _networkConfig.poolIds[0];
}

/**
 * Default pool ID.
 *
 * MIGRATION: Now dynamically determined from loaded config.
 */
export const DEFAULT_POOL_ID = new Proxy({ value: '' }, {
  get(target, prop) {
    if (prop === 'toString' || prop === 'valueOf' || prop === Symbol.toPrimitive) {
      return () => getDefaultPoolId();
    }
    return getDefaultPoolId();
  },
}) as unknown as string;

// =============================================================================
// POOL CONFIG ACCESS
// =============================================================================

/**
 * Get pool config by ID.
 *
 * @param poolId - Pool ID
 * @returns PoolConfig
 * @throws Error if pool not found or not initialized
 */
export function getPoolConfig(poolId: string): PoolConfig {
  if (!_pools) {
    throw new Error(
      'Pool config not initialized. Call initializePoolConfig() at app startup.'
    );
  }

  const config = _pools[poolId];
  if (!config) {
    const available = Object.keys(_pools).join(', ');
    throw new Error(`Unknown pool: ${poolId}. Available pools: ${available}`);
  }
  return config;
}

/**
 * Check if a pool is deployed and ready to use.
 */
export function isPoolDeployed(poolId: string): boolean {
  if (!_pools) return false;
  return poolId in _pools;
}

/**
 * Get only deployed pools for UI.
 */
export function getDeployedPools(): Array<{ id: string; label: string; deployed: boolean }> {
  return getPoolOptions().filter(p => p.deployed);
}

// =============================================================================
// BACKWARD COMPATIBILITY
// =============================================================================

/**
 * Backward compatibility: POOL_CONFIG points to default pool.
 *
 * @deprecated Use getPoolConfig(getDefaultPoolId()) instead
 */
export const POOL_CONFIG = new Proxy({} as PoolConfig, {
  get(target, prop) {
    const defaultId = getDefaultPoolId();
    if (!_pools || !_pools[defaultId]) {
      console.warn(
        '[PoolConfig] Accessing POOL_CONFIG before initialization. ' +
        'Call initializePoolConfig() first.'
      );
      return undefined;
    }
    return (_pools[defaultId] as any)[prop];
  },
});

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

/**
 * Helper to get denomination as BigInt when needed for transactions.
 *
 * @deprecated Use getPoolDenomination(poolId) instead
 */
export function getDenomination(): bigint {
  const defaultId = getDefaultPoolId();
  if (!_pools || !_pools[defaultId]) {
    throw new Error('Pool config not initialized');
  }
  return BigInt(_pools[defaultId].denominationLamports);
}

/**
 * Get denomination for a specific pool.
 */
export function getPoolDenomination(poolId: string): bigint {
  return BigInt(getPoolConfig(poolId).denominationLamports);
}

/**
 * Protocol fee: 0.3%
 */
export const PROTOCOL_FEE_BPS = 30;

/**
 * Calculate protocol fee from denomination.
 */
export function calculateProtocolFee(denomination: bigint): bigint {
  return (denomination * BigInt(PROTOCOL_FEE_BPS)) / 10000n;
}

/**
 * Get withdrawal amount after fee.
 */
export function getWithdrawalAmount(denomination: bigint): bigint {
  return denomination - calculateProtocolFee(denomination);
}

/**
 * Format lamports to SOL display.
 */
export function formatSol(lamports: bigint | number): string {
  const sol = Number(lamports) / 1e9;
  return sol.toFixed(sol >= 1 ? 2 : 3);
}

// =============================================================================
// ASYNC ACCESS (preferred for new code)
// =============================================================================

/**
 * Load pool config asynchronously (preferred for new code).
 *
 * This function handles initialization if needed.
 *
 * @param network - Network name
 * @param poolId - Pool ID
 * @returns Promise<PoolConfig>
 */
export async function loadPoolConfigAsync(
  network: string,
  poolId: string
): Promise<PoolConfig> {
  // Ensure initialized
  if (!_pools || _currentNetwork !== network) {
    await initializePoolConfig(network);
  }

  return getPoolConfig(poolId);
}

/**
 * Load all pools asynchronously (preferred for new code).
 *
 * @param network - Network name
 * @returns Promise<Record<string, PoolConfig>>
 */
export async function loadAllPoolsAsync(
  network: string
): Promise<Record<string, PoolConfig>> {
  // Ensure initialized
  if (!_pools || _currentNetwork !== network) {
    await initializePoolConfig(network);
  }

  return getPools();
}

// =============================================================================
// ON-CHAIN FEE READING
// =============================================================================

// Offset of max_fee_bps in pool state account (after discriminator + other fields)
const MAX_FEE_BPS_OFFSET = 8984;

/**
 * Read max_fee_bps from on-chain pool state.
 *
 * This ensures withdrawal fees match the pool's actual limit,
 * rather than using a hardcoded value that may differ.
 *
 * IMPORTANT: Uses executeWithRotation for proper rate limiting.
 * This prevents 429 errors on rate-limited networks like testnet.
 */
export async function getOnChainMaxFeeBps(
  statePda: string
): Promise<number> {
  const statePubkey = new PublicKey(statePda);
  const accountInfo = await executeWithRotation(
    (connection) => connection.getAccountInfo(statePubkey)
  );
  if (!accountInfo) throw new Error('Pool state not found');
  // max_fee_bps is a u16 at offset 8984 (2-byte LE)
  return accountInfo.data.readUInt16LE(MAX_FEE_BPS_OFFSET);
}

/**
 * Calculate fee using on-chain max_fee_bps.
 */
export function calculateFeeFromBps(
  denominationLamports: bigint,
  maxFeeBps: number
): bigint {
  return (denominationLamports * BigInt(maxFeeBps)) / 10000n;
}
